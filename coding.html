<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <nav>
      <ul>
        <li><a href="/" target="_blank">Oops</a></li>
        <li><a href="js.html" target="_blank">JavaScript</a></li>
        <li>
          <a href="dataStructures.html" target="_blank">Data Structures</a>
        </li>
        <li><a href="coding.html" target="_blank">Coding</a></li>
      </ul>
    </nav>
    <header>
      <h1>Coding Interview Questions</h1>
    </header>
    <div class="questions">
      <ol>
        <li><a href="#last">Get the last element of an array</a></li>
        <li>
          <a href="#second-last">How to get second last element of array</a>
        </li>
        <li>
          <a href="#largest">Program to find largest element in an array</a>
        </li>
        <li>
          <a href="#smallest">Program to find smallest element in an array</a>
        </li>
        <li>
          <a href="#middle">Program to find middle element in an array</a>
        </li>

        <li><a href="#reverse">Program to reverse the array</a></li>
        <li><a href="#sort">Program to sort the array</a></li>
        <li><a href="#empty">How will you empty an array in JavaScript?</a></li>
        <li>
          <a href="#duplicate"
            >How will you remove duplicates from a JS array?</a
          >
        </li>
        <li><a href="#string">Reverse string</a></li>
        <li><a href="#longest">Finding longest word in a string</a></li>
        <li>
          <a href="#char"
            >Print duplicate characters from string in javascript</a
          >
        </li>
        <li>
          <a href="#anar"
            >Write a program in JavaScript to check if two strings are anagrams
            of each other or not</a
          >
        </li>
        <li>
          <a href="#vowels">Program to find vowels in a string</a>
        </li>
        <li>
          <a href="#list">Reverse Linked List</a>
        </li>
        <li>
          <a href="#linear">Implementation of Linear Search in JavaScript</a>
        </li>
        <li>
          <a href="#head">Inserting a Node at the Head of a Linked List</a>
        </li>
        <li>
          <a href="#tail">Inserting a Node at the Tail of a Linked List</a>
        </li>
        <li>
          <a href="#random"
            >Inserting a node at given random position in a singly linked
            list</a
          >
        </li>
        <li>
          <a href="#del">Deleting the first node in a singly linked list</a>
        </li>
      </ol>
    </div>
    <div class="answers">
      <ol>
        <li id="last">
          Using the array length property: <br />
          <code
            >let arry = [1, 2, 3, 4, 5]; <br />
            let lastElement = arry[arry.length -1]; <br />
            console.log(lastElement); //Output: 5</code
          >
          <br />
          <br />
          Using Slice Method: <br />
          <code
            >let arry = [1, 2, 3, 4, 5]; <br />
            let lastElement = arry.slice(-1); <br />
            console.log(lastElement);</code
          >
          <br />
          <br />
          Using pop method: <br />
          <code
            >let arry = [1, 2, 3, 4, 5]; <br />
            let lastElement = arry.pop(); <br />
            console.log(lastElement);</code
          >
          <br />
          As you can see, the pop() method is fastest.
        </li>
        <li id="second-last">
          <code>
            const myNumbers = [100, 200, 300, 400, 500]; <br />
            seconLastNumber = myNumbers.slice(-2, -1)[0]) // 400 <br />
            option two: <br />
            const seconLastNumber = myNumbers[numbers.length - 2];
          </code>
        </li>
        <li id="largest">
          <code>
            var array = [3, 6, 2, 56, 32, 5, 89, 32]; <br />
            var largest = 0; <br />
            for (i = 0; i <= largest; i++) { <br />
            if (array[i] > largest) { <br />
            var largest = array[i]; <br />
            } } <br />
            console.log(largest);
          </code>
        </li>
        <li id="smallest">
          <code>
            var arr = [5, 2, 9, 5, 7]; <br />
            var smallest = arr[0]; <br />
            for (var i = 1; i < arr.length; i++) { <br />
            if (arr[i] < smallest) { <br />
            smallest = arr[i]; <br />
            } <br />
            } <br />
            console.log(smallest);
          </code>
        </li>
        <li id="middle">
          <code>
            var arr = [1, 2, 3, 4, 5]; <br />
            console.log(arr[Math.floor(arr.length / 2)]); o/p - 3
          </code>
        </li>

        <li id="reverse">
          <code>
            let numbers = [1, 2, 3, 4, 5]; <br />
            let reversedNumbers = []; <br />
            for (let i = numbers.length - 1; i >= 0; i--) { <br />
            reversedNumbers.push(numbers[i]); <br />
            } <br />
            console.log(reversedNumbers);
          </code>
        </li>
        <li id="sort">
          <code>
            var numbers = [4, 2, 5, 1, 3]; <br />
            numbers.sort(function (a, b) { <br />
            return a - b; <br />
            }); <br />
            console.log(numbers);
          </code>
        </li>
        <li id="empty">
          <code>
            var array1 = [1, 22, 24, 46]; <br />
            while (array1.length > 0) { <br />
            array1.pop(); <br />
            } <br />
            console.log(array1);
          </code>
        </li>
        <li id="duplicate">
          <code>
            let animals = ["Lion", "Rabbit", "Mouse", "Monkey", "Lion", "Ape"];
            <br />
            let unique = []; <br />
            animals.forEach((item) => { <br />
            if (!unique.includes(item)) { <br />
            unique.push(item); <br />
            } <br />
            }); <br />
            console.log(unique);
          </code>
        </li>
        <li id="string">
          <code>
            function reverseString(str) { <br />
            var newString = ""; <br />
            for (var i = str.length - 1; i >= 0; i--) { <br />
            newString += str[i]; <br />
            } <br />
            console.log(newString); <br />
            } <br />
            reverseString("hello");
          </code>
        </li>
        <li id="longest">
          <code>
            function findLongestWord(str) { <br />
            var strSplit = str.split(" "); <br />
            var longestWord = 0; <br />
            for (var i = 0; i < strSplit.length; i++) { <br />
            if (strSplit[i].length > longestWord) { <br />
            longestWord = strSplit[i].length; <br />
            } <br />
            } <br />
            console.log(longestWord); <br />
            findLongestWord("The quick brown fox jumped over the lazy dog");
          </code>
        </li>
        <li id="char">
          <code>
            function removeDuplicateCharacters(string) { <br />
            return string <br />
            .split("") <br />
            .filter(function (item, pos, self) { <br />
            return self.indexOf(item) == pos; <br />
            }) <br />
            .join(""); <br />
            } <br />
            console.log(removeDuplicateCharacters("baraban"));
          </code>
        </li>
        <li id="anar">
          <code>
            function checkStringsAnagram(a, b) { <br />
            let len1 = a.length; <br />
            let len2 = b.length; <br />
            if (len1 !== len2) { <br />
            console.log("Invalid Input"); <br />
            return; <br />
            } <br />
            let str1 = a.split("").sort().join(""); <br />
            let str2 = b.split("").sort().join(""); <br />
            if (str1 === str2) { <br />
            console.log("True"); <br />
            } else { <br />
            console.log("False"); <br />
            } <br />
            } <br />
            checkStringsAnagram("indian", "ndiani");
          </code>
        </li>
        <li id="vowels">
          <code>
            const vowels = ["a", "e", "i", "o", "u"]; <br />
            function countVowel(str) { <br />
            let count = 0; <br />
            for (let letter of str.toLowerCase()) { <br />
            if (vowels.includes(letter)) { <br />
            count++; <br />
            } <br />
            } <br />
            return count; <br />
            } <br />
            let result = countVowel("Hello my name is Imran"); <br />
            console.log(result);
          </code>
        </li>
        <li id="list">
          First, I’m going to initialize 3 pointers: <br />
          prev -> Because it’a a singly linked list, a node does not have
          reference to its previous node. That’s why we need prev pointer to
          store a previous element of the node beforehand. <br />
          curr -> to know which node we are currently at. <br />
          nextTemp -> to store the next node before changing the reference. If
          we change the current’s next value without saving it, we are going to
          lose our next pointer in the iteration.
          <code>
            var reverseList = function(head) { <br />
            let prev = null; <br />
            let curr = head; <br />
            let nextTemp = null; <br />

            while(curr!= null) { <br />
            nextTemp = curr.next; // As I explained earlier, I save the next
            pointer in the temp variable. <br />
            curr.next = prev; // Then I reverse the pointer of the current node
            to its previous node. <br />
            prev = curr; // The previous node becomes the node we are currently
            at. <br />
            curr = nextTemp; // And the current nodes becomes the next node we
            saved earlier. And we keep iterating. <br />
            } <br />
            return prev // At the end, our previous node will be the head node
            of the new list. <br />
            }; <br />
          </code>
        </li>
        <li id="linear">
          We can traverse through the given list using a for loop. Let's look at
          the implementation of Linear Search: <br />
          <code>
            function linearSearch(arr, key){ <br />
            for(let i = 0; i < arr.length; i++){ <br />
            if(arr[i] === key){ <br />
            return i <br />
            } <br />
            } <br />
            return -1 <br />
            } <br />
            Here we are going through all the elements in an array and comparing
            each element with the key. If we find a match, we return the index
            of the element. In our case, the variable i keeps track of where we
            are in the array, and if we find a match, we return the current
            value for i. In case the element doesn't exist in our list, the
            linearSearch function won't return any i value from the loop. We
            just return -1 after the loop to show that the function didn't find
            the desired element. <br />
            Time Complexity: O(n)
          </code>
        </li>
        <li id="head">
          The problem is straightforward, let’s move to the solution: <br />
          Initialize a node class. <br />
          Create a new node with the given value. <br />
          If the list is empty, set the new node as the head and return it.
          <br />
          If the list is not empty, set the next of the new node as the head and
          then change the head pointer to point to the new node. <br />
          Return the new head of the updated linked list. <br />
          O(1) time complexity. <br />
          <code>
            class SinglyLinkedListNode{ <br />
            constructor(val){ <br />
            this.val = val <br />
            this.next = null <br />
            } <br />
            } <br />
            <br />
            function insertNodeAtHead(head, data){ <br />
            let newNode = new SinglyLinkedListNode(data) <br />
            if(!head){ <br />
            head = newNode <br />
            return head <br />
            }else{ <br />
            newNode.next = head <br />
            head = newNode <br />
            } <br />
            return head <br />
            }
          </code>
        </li>
        <li id="tail">
          Initialize a node class. <br />
          Create a new node with the given value. <br />
          If the list is empty, set the new node as the head and return it.
          <br />
          If the list is not empty, create a variable called current to traverse
          the list and set it to the head. <br />
          Loop through the next variables in each node till the last node.
          <br />
          Change the next of the last node to the new node. <br />
          Return the head of the updated linked list. <br />
          Since we traverse the given list from head to end, time complexity of
          this solution is O(n) <br />
          <code>
            class SinglyLinkedListNode { <br />
            constructor(val) { <br />
            this.val = val <br />
            this.next = null <br />
            } <br />
            } <br />
            <br />
            function insertNodeAtTail(head, data) { <br />
            let newNode = new SinglyLinkedListNode(data)<br />
            if (!head) {<br />
            head = newNode <br />
            return head <br />
            }<br />
            let current = head <br />
            while (current.next) { <br />
            current = current.next <br />
            } <br />
            current.next = newNode <br />
            return head <br />
            } <br />
          </code>
        </li>
        <li id="random">
          To implement this operation we will have to traverse the list until we
          reach the desired position node. We will then assign the newNode’s
          next pointer to the next node to the position node. The position
          node’s next pointer can then be updated to point to the newNode.
          <br />
          <code>
            // A helper function getAt() is defined to get to the desired
            position. This function can also be later used for performing delete
            operation from a given position. <br />
            LinkedList.prototype.getAt = function(index){ <br />
            let counter = 0; <br />
            let node = this.head; <br />
            while (node) {<br />
            if (counter === index) {<br />
            return node;<br />
            }<br />
            counter++;<br />
            node = node.next;<br />
            }<br />
            return null;<br />
            }<br />
            // The insertAt() function contains the steps to insert a node at a
            given index.<br />
            LinkedList.prototype.insertAt = function(data, index){<br />
            if (!this.head) {<br />
            this.head = new Node(data);<br />
            return;<br />
            }<br />
            // if new node needs to be inserted at the front of the list i.e.
            before the head. <br />
            if (index === 0) {<br />
            this.head = new Node(data, this.head);<br />
            return;<br />
            }<br />
            // else, use getAt() to find the previous node.<br />
            const previous = this.getAt(index - 1);<br />
            let newNode = new Node(data);<br />
            newNode.next = previous.next;<br />
            previous.next = newNode; <br />
            return this.head<br />
            }<br />
          </code>
        </li>
        <li id="del"></li>
      </ol>
    </div>
  </body>
</html>
