<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coding</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <nav>
      <ul>
        <li><a href="/" target="_blank">Oops</a></li>
        <li><a href="js.html" target="_blank">JavaScript</a></li>
        <li>
          <a href="dataStructures.html" target="_blank">Data Structures</a>
        </li>
        <li><a href="coding.html" target="_blank">Coding</a></li>
      </ul>
    </nav>
    <header>
      <h1>Coding Interview Questions</h1>
    </header>
    <div class="questions">
      <ol>
        <li><a href="#last">Get the last element of an array</a></li>
        <li>
          <a href="#second-last">How to get second last element of array</a>
        </li>
        <li>
          <a href="#largest">Program to find largest element in an array</a>
        </li>
        <li>
          <a href="#smallest">Program to find smallest element in an array</a>
        </li>
        <li>
          <a href="#middle">Program to find middle element in an array</a>
        </li>

        <li><a href="#reverse">Program to reverse the array</a></li>
        <li><a href="#sort">Program to sort the array</a></li>
        <li><a href="#empty">How will you empty an array in JavaScript?</a></li>
        <li>
          <a href="#duplicate"
            >How will you remove duplicates from a JS array?</a
          >
        </li>
        <li><a href="#miss">Find missing number in an array</a></li>
        <li><a href="#string">Reverse string</a></li>
        <li><a href="#longest">Finding longest word in a string</a></li>
        <li>
          <a href="#char"
            >Print duplicate characters from string in javascript</a
          >
        </li>
        <li>
          <a href="#anar"
            >Write a program in JavaScript to check if two strings are anagrams
            of each other or not</a
          >
        </li>
        <li>
          <a href="#vowels">Program to find vowels in a string</a>
        </li>
        <li>
          <a href="#list">Reverse Linked List</a>
        </li>
        <li>
          <a href="#linear">Implementation of Linear Search in JavaScript</a>
        </li>
        <li>
          <a href="#head">Inserting a Node at the Head of a Linked List</a>
        </li>
        <li>
          <a href="#tail">Inserting a Node at the Tail of a Linked List</a>
        </li>
        <li>
          <a href="#random"
            >Inserting a node at given random position in a singly linked
            list</a
          >
        </li>
        <li>
          <a href="#del">Deleting the first node in a singly linked list</a>
        </li>
        <li>
          <a href="#last">Deleting the last node in a singly linked list</a>
        </li>
        <li>
          <a href="#pos"
            >Deleting a node from given random position in a singly linked
            list</a
          >
        </li>
        <li>
          <a href="#whole">Deleting the singly linked list</a>
        </li>
        <li>
          <a href="#cre">Creating Stack</a>
        </li>
        <li>
          <a href="#pu">Insert an Element to the Top of Stack (Push)</a>
        </li>
        <li>
          <a href="#len">Returns the Length of the Stack</a>
        </li>
        <li>
          <a href="#top">Get the Top Element of the Stack</a>
        </li>
        <li>
          <a href="#emp">Checks If the Stack Is Empty (isEmpty)</a>
        </li>
        <li>
          <a href="#pop">Deletes an Element at the Top of the Stack (Pop)</a>
        </li>
        <li>
          <a href="#print">Print the Elements of the Stack (Print)</a>
        </li>
        <li>
          <a href="#rev">Reverse the Stack</a>
        </li>
        <li>
          <a href="#queue">Implementing a queue in JavaScript</a>
        </li>
      </ol>
    </div>
    <div class="answers">
      <ol>
        <li id="last">
          Using the array length property: <br />
          <code
            >let arry = [1, 2, 3, 4, 5]; <br />
            let lastElement = arry[arry.length -1]; <br />
            console.log(lastElement); //Output: 5</code
          >
          <br />
          <br />
          Using Slice Method: <br />
          <code
            >let arry = [1, 2, 3, 4, 5]; <br />
            let lastElement = arry.slice(-1); <br />
            console.log(lastElement);</code
          >
          <br />
          <br />
          Using pop method: <br />
          <code
            >let arry = [1, 2, 3, 4, 5]; <br />
            let lastElement = arry.pop(); <br />
            console.log(lastElement);</code
          >
          <br />
          As you can see, the pop() method is fastest.
        </li>
        <li id="second-last">
          <code>
            const myNumbers = [100, 200, 300, 400, 500]; <br />
            seconLastNumber = myNumbers.slice(-2, -1)[0]) // 400 <br />
            option two: <br />
            const seconLastNumber = myNumbers[numbers.length - 2];
          </code>
        </li>
        <li id="largest">
          <code>
            var array = [3, 6, 2, 56, 32, 5, 89, 32]; <br />
            var largest = 0; <br />
            for (i = 0; i <= largest; i++) { <br />
            if (array[i] > largest) { <br />
            var largest = array[i]; <br />
            } } <br />
            console.log(largest);
          </code>
        </li>
        <li id="smallest">
          <code>
            var arr = [5, 2, 9, 5, 7]; <br />
            var smallest = arr[0]; <br />
            for (var i = 1; i < arr.length; i++) { <br />
            if (arr[i] < smallest) { <br />
            smallest = arr[i]; <br />
            } <br />
            } <br />
            console.log(smallest);
          </code>
        </li>
        <li id="middle">
          <code>
            var arr = [1, 2, 3, 4, 5]; <br />
            console.log(arr[Math.floor(arr.length / 2)]); o/p - 3
          </code>
        </li>

        <li id="reverse">
          <code>
            let numbers = [1, 2, 3, 4, 5]; <br />
            let reversedNumbers = []; <br />
            for (let i = numbers.length - 1; i >= 0; i--) { <br />
            reversedNumbers.push(numbers[i]); <br />
            } <br />
            console.log(reversedNumbers);
          </code>
        </li>
        <li id="sort">
          <code>
            var numbers = [4, 2, 5, 1, 3]; <br />
            numbers.sort(function (a, b) { <br />
            return a - b; <br />
            }); <br />
            console.log(numbers);
          </code>
        </li>
        <li id="empty">
          <code>
            var array1 = [1, 22, 24, 46]; <br />
            while (array1.length > 0) { <br />
            array1.pop(); <br />
            } <br />
            console.log(array1);
          </code>
        </li>
        <li id="duplicate">
          <code>
            let animals = ["Lion", "Rabbit", "Mouse", "Monkey", "Lion", "Ape"];
            <br />
            let unique = []; <br />
            animals.forEach((item) => { <br />
            if (!unique.includes(item)) { <br />
            unique.push(item); <br />
            } <br />
            }); <br />
            console.log(unique);
          </code>
        </li>
        <li id="miss">
          Steps: <br />
          Set up the function <br />
          Create a variable that counts for you <br />
          Create a loop that runs through the array <br />
          Use a counter and compare it to the elements of the array <br />
          Thats it! If the counter is not equal to the corresponding element in
          the array then return the missing number! <br />
          <code>
            function missing(arr) {<br />
            var x = 0;<br />
            for (var i = 0; i < arr.length; i++) {<br />
            x = x + 1;<br />
            if (arr[i] != x) {<br />
            console.log(x);<br />
            }<br />
            }<br />
            }<br />
            missing([1, 2, 3, 4, 5, 6, 7, 8, 10]);
          </code>
        </li>
        <li id="string">
          <code>
            function reverseString(str) { <br />
            var newString = ""; <br />
            for (var i = str.length - 1; i >= 0; i--) { <br />
            newString += str[i]; <br />
            } <br />
            console.log(newString); <br />
            } <br />
            reverseString("hello");
          </code>
        </li>
        <li id="longest">
          <code>
            function findLongestWord(str) { <br />
            var strSplit = str.split(" "); <br />
            var longestWord = 0; <br />
            for (var i = 0; i < strSplit.length; i++) { <br />
            if (strSplit[i].length > longestWord) { <br />
            longestWord = strSplit[i].length; <br />
            } <br />
            } <br />
            console.log(longestWord); <br />
            findLongestWord("The quick brown fox jumped over the lazy dog");
          </code>
        </li>
        <li id="char">
          <code>
            function removeDuplicateCharacters(string) { <br />
            return string <br />
            .split("") <br />
            .filter(function (item, pos, self) { <br />
            return self.indexOf(item) == pos; <br />
            }) <br />
            .join(""); <br />
            } <br />
            console.log(removeDuplicateCharacters("baraban"));
          </code>
        </li>
        <li id="anar">
          <code>
            function checkStringsAnagram(a, b) { <br />
            let len1 = a.length; <br />
            let len2 = b.length; <br />
            if (len1 !== len2) { <br />
            console.log("Invalid Input"); <br />
            return; <br />
            } <br />
            let str1 = a.split("").sort().join(""); <br />
            let str2 = b.split("").sort().join(""); <br />
            if (str1 === str2) { <br />
            console.log("True"); <br />
            } else { <br />
            console.log("False"); <br />
            } <br />
            } <br />
            checkStringsAnagram("indian", "ndiani");
          </code>
        </li>
        <li id="vowels">
          <code>
            const vowels = ["a", "e", "i", "o", "u"]; <br />
            function countVowel(str) { <br />
            let count = 0; <br />
            for (let letter of str.toLowerCase()) { <br />
            if (vowels.includes(letter)) { <br />
            count++; <br />
            } <br />
            } <br />
            return count; <br />
            } <br />
            let result = countVowel("Hello my name is Imran"); <br />
            console.log(result);
          </code>
        </li>
        <li id="list">
          First, I’m going to initialize 3 pointers: <br />
          prev -> Because it’a a singly linked list, a node does not have
          reference to its previous node. That’s why we need prev pointer to
          store a previous element of the node beforehand. <br />
          curr -> to know which node we are currently at. <br />
          nextTemp -> to store the next node before changing the reference. If
          we change the current’s next value without saving it, we are going to
          lose our next pointer in the iteration.
          <code>
            var reverseList = function(head) { <br />
            let prev = null; <br />
            let curr = head; <br />
            let nextTemp = null; <br />

            while(curr!= null) { <br />
            nextTemp = curr.next; // As I explained earlier, I save the next
            pointer in the temp variable. <br />
            curr.next = prev; // Then I reverse the pointer of the current node
            to its previous node. <br />
            prev = curr; // The previous node becomes the node we are currently
            at. <br />
            curr = nextTemp; // And the current nodes becomes the next node we
            saved earlier. And we keep iterating. <br />
            } <br />
            return prev // At the end, our previous node will be the head node
            of the new list. <br />
            }; <br />
          </code>
        </li>
        <li id="linear">
          We can traverse through the given list using a for loop. Let's look at
          the implementation of Linear Search: <br />
          <code>
            function linearSearch(arr, key){ <br />
            for(let i = 0; i < arr.length; i++){ <br />
            if(arr[i] === key){ <br />
            return i <br />
            } <br />
            } <br />
            return -1 <br />
            } <br />
            Here we are going through all the elements in an array and comparing
            each element with the key. If we find a match, we return the index
            of the element. In our case, the variable i keeps track of where we
            are in the array, and if we find a match, we return the current
            value for i. In case the element doesn't exist in our list, the
            linearSearch function won't return any i value from the loop. We
            just return -1 after the loop to show that the function didn't find
            the desired element. <br />
            Time Complexity: O(n)
          </code>
        </li>
        <li id="head">
          The problem is straightforward, let’s move to the solution: <br />
          Initialize a node class. <br />
          Create a new node with the given value. <br />
          If the list is empty, set the new node as the head and return it.
          <br />
          If the list is not empty, set the next of the new node as the head and
          then change the head pointer to point to the new node. <br />
          Return the new head of the updated linked list. <br />
          O(1) time complexity. <br />
          <code>
            class SinglyLinkedListNode{ <br />
            constructor(val){ <br />
            this.val = val <br />
            this.next = null <br />
            } <br />
            } <br />
            <br />
            function insertNodeAtHead(head, data){ <br />
            let newNode = new SinglyLinkedListNode(data) <br />
            if(!head){ <br />
            head = newNode <br />
            return head <br />
            }else{ <br />
            newNode.next = head <br />
            head = newNode <br />
            } <br />
            return head <br />
            }
          </code>
        </li>
        <li id="tail">
          Initialize a node class. <br />
          Create a new node with the given value. <br />
          If the list is empty, set the new node as the head and return it.
          <br />
          If the list is not empty, create a variable called current to traverse
          the list and set it to the head. <br />
          Loop through the next variables in each node till the last node.
          <br />
          Change the next of the last node to the new node. <br />
          Return the head of the updated linked list. <br />
          Since we traverse the given list from head to end, time complexity of
          this solution is O(n) <br />
          <code>
            class SinglyLinkedListNode { <br />
            constructor(val) { <br />
            this.val = val <br />
            this.next = null <br />
            } <br />
            } <br />
            <br />
            function insertNodeAtTail(head, data) { <br />
            let newNode = new SinglyLinkedListNode(data)<br />
            if (!head) {<br />
            head = newNode <br />
            return head <br />
            }<br />
            let current = head <br />
            while (current.next) { <br />
            current = current.next <br />
            } <br />
            current.next = newNode <br />
            return head <br />
            } <br />
          </code>
        </li>
        <li id="random">
          To implement this operation we will have to traverse the list until we
          reach the desired position node. We will then assign the newNode’s
          next pointer to the next node to the position node. The position
          node’s next pointer can then be updated to point to the newNode.
          <br />
          <code>
            // A helper function getAt() is defined to get to the desired
            position. This function can also be later used for performing delete
            operation from a given position. <br />
            LinkedList.prototype.getAt = function(index){ <br />
            let counter = 0; <br />
            let node = this.head; <br />
            while (node) {<br />
            if (counter === index) {<br />
            return node;<br />
            }<br />
            counter++;<br />
            node = node.next;<br />
            }<br />
            return null;<br />
            }<br />
            // The insertAt() function contains the steps to insert a node at a
            given index.<br />
            LinkedList.prototype.insertAt = function(data, index){<br />
            if (!this.head) {<br />
            this.head = new Node(data);<br />
            return;<br />
            }<br />
            // if new node needs to be inserted at the front of the list i.e.
            before the head. <br />
            if (index === 0) {<br />
            this.head = new Node(data, this.head);<br />
            return;<br />
            }<br />
            // else, use getAt() to find the previous node.<br />
            const previous = this.getAt(index - 1);<br />
            let newNode = new Node(data);<br />
            newNode.next = previous.next;<br />
            previous.next = newNode; <br />
            return this.head<br />
            }<br />
          </code>
        </li>
        <li id="del">
          The first node in a linked list is pointed by the head pointer. To
          perform a delete operation at the beginning of the list, we will have
          to make the next node to the head node as the new head. <br />
          <code>
            LinkedList.prototype.deleteFirstNode = function(){ <br />
            if(!this.head){<br />
            return;<br />
            }<br />
            this.head = this.head.next;<br />
            return this.head;<br />
            }<br />
          </code>
        </li>
        <li id="last">
          To remove the last node from the list, we will first have to traverse
          the list to find the last node and at the same time maintain an extra
          pointer to point at the node before the last node. To delete the last
          node, we will then set the next pointer of the node before the last
          node to null.
        </li>
        <li id="pos">
          We will first have to traverse the list to find the desired node to be
          deleted and at the same time maintain an extra pointer to point at the
          node before the desired node. <br />
          <code>
            inkedList.prototype.deleteAt = function(index){<br />
            // when list is empty i.e. head = null<br />
            if (!this.head) {<br />
            this.head = new Node(data);<br />
            return;<br />
            }<br />
            // node needs to be deleted from the front of the list i.e. before
            the head.<br />
            if (index === 0) {<br />
            this.head = this.head.next;<br />
            return;<br />
            }<br />
            // else, use getAt() to find the previous node.<br />
            const previous = this.getAt(index - 1);<br />

            if (!previous || !previous.next) {<br />
            return;<br />
            }<br />

            previous.next = previous.next.next; <br />
            return this.head<br />
            }
          </code>
        </li>
        <li id="whole">
          LinkedList.prototype.deleteList = function(){ <br />
          this.head = null; <br />
          }
        </li>
        <li id="cre">
          class Stack { <br />
          constructor(){ <br />
          this.data = []; <br />
          this.top = 0; <br />
          } <br />
          } <br />
          The Stack class has two attributes: <br />
          data → Is an array in which we store the value. <br />
          top → Points to the top element index.
        </li>
        <li id="pu">
          When we push an element to the stack, we have to store it in the top
          position of data and need to increment the top variable so that the
          top will point to the next empty place. <br />
          <code>
            push(element) {<br />
            this.data[this.top] = element;<br />
            this.top = this.top + 1;<br />
            }<br />
          </code>
        </li>
        <li id="len">
          To get the length of the stack, we can return the top value. <br />
          <code
            >length() { <br />
            return this.top; <br />
            }</code
          >
        </li>
        <li id="top">
          To get the peek element of the stack, we can use the top-1 attribute
          of Stack class: <br />
          <code
            >peek() { <br />
            return this.data[this.top -1 ]; <br />
            }</code
          >
          <br />In above code we used top-1 because the top points to the
          position where the new element is to be inserted, therefore the top
          empty location.
        </li>
        <li id="emp">
          If the value of the top is equal to 0 then there is no element in the
          Stack. <br />
          <code
            >isEmpty() { <br />
            return this.top === 0; <br />
            }</code
          >
        </li>
        <li id="pop">
          When we pop an element from the stack, we have to remove the element
          in the top position of data and need to decrement the top variable so
          that the top will point to the previous element’s position. We need to
          ensure that the stack is not empty, otherwise the value of the top
          will be decremented below zero. So, the above code will be like this:
          <br />
          <code
            >pop() { <br />
            if( this.isEmpty() === false ) {<br />
            this.top = this.top -1;<br />
            return this.data.pop(); // removes the last element<br />
            }<br />
            }</code
          >
        </li>
        <li id="print">
          function print() { <br />
          var top = this.top - 1; // because top points to index where new
          element to be inserted<br />
          while(top >= 0) { // print upto 0th index<br />
          console.log(this.data[top]);<br />
          top--;<br />
          }<br />
          }
        </li>
        <li id="rev">
          function reverse() {<br />
          this._reverse(this.top - 1 );<br />
          }<br />
          function _reverse(index) {<br />
          if(index != 0) {<br />
          this._reverse(index-1);<br />
          }<br />
          console.log(this.data[index]);<br />
          }
        </li>
        <li id="queue">
          Constant time: O(1) <br />
          <code>
            class Queue {<br />
            constructor() {<br />
            this.items = {};<br />
            this.headIndex = 0;<br />
            this.tailIndex = 0;<br />
            }<br />
            enqueue(item) {<br />
            this.items[this.tailIndex] = item;<br />
            this.tailIndex++;<br />
            }<br />
            dequeue() {<br />
            const item = this.items[this.headIndex];<br />
            delete this.items[this.headIndex];<br />
            this.headIndex++;<br />
            return item;<br />
            }<br />
            peek() {<br />
            return this.items[this.headIndex];<br />
            }<br />
            get length() {<br />
            return this.tailIndex - this.headIndex;<br />
            }<br />
            }<br />
            const queue = new Queue();<br />
            queue.enqueue(7);<br />
            queue.enqueue(2);<br />
            queue.enqueue(6);<br />
            queue.enqueue(4);<br />
            queue.dequeue(); // => 7<br />
            queue.peek(); // => 2<br />
            queue.length; // => 3 <br />
            const queue = new Queue() is how you create an instance of a
            queue.<br />
            Calling queue.enqueue(7) method enqueues the item 7 into the
            queue.<br />
            queue.dequeue() dequeues a head item from the queue, while
            queue.peek() just peeks the item at the head.<br />
            Finally, queue.length shows how many items are still in the
            queue.<br />
          </code>
        </li>
      </ol>
    </div>
  </body>
</html>
