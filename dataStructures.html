<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DS</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <nav>
      <ul>
        <li><a href="/" target="_blank">Oops</a></li>
        <li><a href="js.html" target="_blank">JavaScript</a></li>
        <li>
          <a href="dataStructures.html" target="_blank">Data Structures</a>
        </li>
        <li><a href="coding.html" target="_blank">Coding</a></li>
      </ul>
    </nav>
    <header>
      <h1>Data Structures Interview</h1>
    </header>
    <div class="questions">
      <ol>
        <li><a href="#ds">What is Data Structure?</a></li>
        <li><a href="#type-ds">Describe the types of Data Structures?</a></li>
        <li>
          <a href="#app-ds">List the area of applications of Data Structure.</a>
        </li>
        <li>
          <a href="#file-storage"
            >What is the difference between file structure and storage
            structure?</a
          >
        </li>
        <li>
          <a href="#diff-ds"
            >What are the various operations that can be performed on different
            Data Structures?</a
          >
        </li>
        <li>
          <a href="#list-ds"
            >List the data structures which are used in RDBMS, Network Data
            Modal, and Hierarchical Data Model.</a
          >
        </li>
        <li>
          <a href="#searc"
            >What are the types of searching used in Data Structures?</a
          >
        </li>
        <li>
          <a href="#recursion"
            >Which data structure is used to perform recursion?</a
          >
        </li>
        <li>
          <a href="#stack">What is a Stack?</a>
        </li>
        <li>
          <a href="#stack-app"
            >List the area of applications where stack data structure can be
            used?</a
          >
        </li>
        <li>
          <a href="#op-stack"
            >What are the operations that can be performed on a stack?</a
          >
        </li>
        <li>
          <a href="#overflow">Write the stack overflow condition.</a>
        </li>
        <li>
          <a href="#push-pop">What is the difference between PUSH and POP?</a>
        </li>
        <li>
          <a href="#postfix">What is a postfix expression?</a>
        </li>
        <li>
          <a href="#array">What is an array?</a>
        </li>
        <li>
          <a href="#dyna">What are dynamic arrays?</a>
        </li>
        <li>
          <a href="#charac"
            >Name some characteristics of Array Data Structure.</a
          >
        </li>
        <li>
          <a href="#one-d"
            >How to reference all the elements in a one-dimension array?</a
          >
        </li>
        <li>
          <a href="#mul-d">What is a multidimensional array?</a>
        </li>
        <li>
          <a href="#mem"
            >How are the elements of a 2D array are stored in the memory?</a
          >
        </li>
        <li>
          <a href="#link-list">Define Linked List Data structure</a>
        </li>
        <li>
          <a href="#cons"
            >Are linked lists considered linear or non-linear data
            structures?</a
          >
        </li>
        <li>
          <a href="#tip">What are the different types of linked lists? </a>
        </li>
        <li>
          <a href="#ad-array"
            >What are the advantages of Linked List over an array?</a
          >
        </li>
        <li>
          <a href="#d-link">What is doubly linked list?</a>
        </li>
        <li>
          <a href="#queue">Define the queue data structure.</a>
        </li>
        <li>
          <a href="#queue-app"
            >List some applications of queue data structure.</a
          >
        </li>
        <li>
          <a href="#dr-queue"
            >What are the drawbacks of array implementation of Queue?</a
          >
        </li>
        <li>
          <a href="#implement">How to implement a queue using stack?</a>
        </li>
        <li>
          <a href="#dequeue">What is a dequeue?</a>
        </li>
        <li>
          <a href="#minimum"
            >What is the minimum number of queues that can be used to implement
            a priority queue?</a
          >
        </li>
        <li>
          <a href="#tree">Define the tree data structure.</a>
        </li>
        <li>
          <a href="#tree-list">List the types of tree.</a>
        </li>
        <li>
          <a href="#bin">What are Binary trees?</a>
        </li>
        <li>
          <a href="#nodes"
            >What is the maximum number of nodes in a binary tree of height
            k?</a
          >
        </li>
        <li>
          <a href="#suits"
            >Which data structure suits the most in the tree construction?</a
          >
        </li>
        <li>
          <a href="#prop">State the properties of B Tree.</a>
        </li>
        <li>
          <a href="#tree-ds">List some applications of Tree-data structure?</a>
        </li>
        <li>
          <a href="#graph">Define the graph data structure and uses?</a>
        </li>
        <li>
          <a href="#rep"
            >What are the Data Structures that are used to represent graphs?</a
          >
        </li>
        <li>
          <a href="#cycle">Differentiate among cycle, path, and circuit?</a>
        </li>
        <li>
          <a href="#imple"
            >Mention the data structures which are used in graph
            implementation.</a
          >
        </li>
        <li>
          <a href="#bfs"
            >Which data structures are used in BFS and DFS algorithm?</a
          >
        </li>
        <li>
          <a href="#graph-data"
            >What are the applications of Graph data structure?</a
          >
        </li>
        <li>
          <a href="#scene">In what scenario, Binary Search can be used?</a>
        </li>
        <li>
          <a href="#advantage"
            >What are the advantages of Binary search over linear search?</a
          >
        </li>
        <li>
          <a href="#selection">What are the advantages of Selecetion Sort?</a>
        </li>
        <li>
          <a href="#multi-linked"
            >List Some Applications of Multilinked Structures?</a
          >
        </li>
        <li>
          <a href="#null">What is the difference between NULL and VOID?</a>
        </li>
        <li>
          <a href="#hash">What is Hash Map?</a>
        </li>
        <li>
          <a href="#hashmap"
            >What is the requirement for an object to be used as key or value in
            HashMap?</a
          >
        </li>
        <li>
          <a href="#basic"
            >What is the time complexity of basic operations get() and put() in
            HashMap class?</a
          >
        </li>
        <li>
          <a href="#lru"
            >Which data structures are used for implementing LRU cache?</a
          >
        </li>
        <li>
          <a href="#prio">What is a priority queue?</a>
        </li>
        <li>
          <a href="#dup">Can we store a duplicate key in HashMap?</a>
        </li>
        <li>
          <a href="#t-traverse">What are tree traversals?</a>
        </li>
        <li>
          <a href="#bst">What is a Binary Search Tree?</a>
        </li>
        <li>
          <a href="#avl">What is an AVL Tree?</a>
        </li>
        <li>
          <a href="#bfs">Breadth First Search bfs</a>
        </li>
        <li>
          <a href="#dfs">Depth First Search dfs</a>
        </li>
        <li>
          <a href="#topo">What is topological sorting in a graph?</a>
        </li>
        <li>
          <a href="#heap">What is a heap data structure?</a>
        </li>
        <li>
          <a href="#algo">What is an Algorithm?</a>
        </li>
        <li>
          <a href="#need">Need for Algorithm?</a>
        </li>
        <li>
          <a href="#comp">What is the Complexity of Algorithm?</a>
        </li>
        <li>
          <a href="#rev">Write an algorithm to reverse a string.</a>
        </li>
        <li>
          <a href="#greedy">Greedy Algorithm</a>
        </li>
        <li>
          <a href="#app">Algorithm's that use greedy approach.</a>
        </li>
        <li>
          <a href="#divide">Divide and Conquer</a>
        </li>
        <li>
          <a href="#dynamic">Dynamic Programming</a>
        </li>
        <li>
          <a href="#circle">Circular Linked List</a>
        </li>
        <li>
          <a href="#note"
            >Expression parsing or notation (Infix, Prefix and Postfix).</a
          >
        </li>
        <li>
          <a href="#line">Linear Search</a>
        </li>
        <li>
          <a href="#lif">LIFO FIFO</a>
        </li>
        <li>
          <a href="#prio">What is a priority queue?</a>
        </li>
        <li>
          <a href="#hp">Binary Heap</a>
        </li>
        <li>
          <a href="#what">What Data Structures make use of pointers?</a>
        </li>
        <li>
          <a href="#over"
            >What is the meaning of the stack overflow condition?</a
          >
        </li>
        <li>
          <a href="#bal">What is a Balanced Tree and why is that important?</a>
        </li>
        <li>
          <a href="#bin">What is binary search?</a>
        </li>
        <li>
          <a href="#lin">What is linear search?</a>
        </li>
        <li>
          <a href="#tim"
            >What are the time complexities of linear search and binary
            search?</a
          >
        </li>
        <li>
          <a href="#trav">Tell me about tree traversal.</a>
        </li>
        <li>
          <a href="#kruk">How does Kruskal's algorithm work?</a>
        </li>
        <li>
          <a href="#prim">Prim's Algorithm</a>
        </li>
        <li>
          <a href="#mst">What is a minimum spanning tree (MST)?</a>
        </li>
        <li>
          <a href="#hanoi">Explain the Tower of Hanoi Problem.</a>
        </li>
        <li>
          <a href="#rec">What are recursive algorithms?</a>
        </li>
        <li>
          <a href="#why">Explain why stack is a recursive data structure?</a>
        </li>
        <li>
          <a href="#comp">What is merge sort time complexity?</a>
        </li>
        <li>
          <a href="#shell">What is shell sort?</a>
        </li>
        <li>
          <a href="#is">What is quicksort time complexity?</a>
        </li>
        <li>
          <a href="#red">What is a Red-Black Tree?</a>
        </li>
        <li>
          <a href="#occ">When does the worst case of QuickSort occur?</a>
        </li>
        <li>
          <a href="#are"
            >Which data structures are used for the BFS and DFS of a graph?</a
          >
        </li>
      </ol>
    </div>
    <div class="answers">
      <ol>
        <li id="ds">
          The data structure is a way that specifies how to organize and
          manipulate the data. It also defines the relationship between them.
          Some examples of Data Structures are arrays, Linked List, Stack,
          Queue, etc.
        </li>
        <li id="type-ds">
          Data Structures are mainly classified into two types: <br />
          Linear Data Structure: A data structure is called linear if all of its
          elements are arranged in the sequential order. In linear data
          structures, the elements are stored in a non-hierarchical way where
          each item has the successors and predecessors except the first and
          last element. <br />
          Non-Linear Data Structure: The Non-linear data structure does not form
          a sequence i.e. each item or element is connected with two or more
          other items in a non-linear arrangement. The data elements are not
          arranged in the sequential structure.
        </li>
        <li id="app-ds">
          Data structures are applied extensively in the following areas of
          computer science: Compiler Design, Operating System, Database
          Management System, Statistical analysis package, Numerical Analysis,
          Graphics, Artificial Intelligence, Simulation
        </li>
        <li id="file-storage">
          Storage structure: It is the representation of the data structure in
          the computer memory. File structure: It is the representation of the
          storage structure in the auxiliary memory.
        </li>
        <li id="diff-ds">
          Insertion ? Add a new data item in the given collection of data items.
          <br />
          Deletion ? Delete an existing data item from the given collection of
          data items. <br />
          Traversal ? Access each data item exactly once so that it can be
          processed. <br />
          Searching ? Find out the location of the data item if it exists in the
          given collection of data items. <br />
          Sorting ? Arranging the data items in some order i.e. in ascending or
          descending order in case of numerical data and in dictionary order in
          case of alphanumeric data.
        </li>
        <li id="list-ds">
          RDBMS uses Array data structure Network data model uses Graph
          Hierarchal data model uses Trees
        </li>
        <li id="recursion">
          Stack data structure is used in recursion due to its last in first out
          nature. Operating system maintains the stack in order to save the
          iteration variables at each function call.
        </li>
        <li id="stack">
          Stack is an ordered list in which, insertion and deletion can be
          performed only at one end that is called the top. It is a recursive
          data structure having pointer to its top element. The stack is
          sometimes called as Last-In-First-Out (LIFO) list i.e. the element
          which is inserted first in the stack will be deleted last from the
          stack.
        </li>
        <li id="stack-app">
          Expression evaluation Backtracking Memory Management Function calling
          and return
        </li>
        <li id="op-stack">Push Operations Pop Operations Peek Operations</li>
        <li id="overflow">Overflow occurs when top = Maxsize -1</li>
        <li id="push-pop">
          PUSH: PUSH specifies that data is being "inserted" into the stack.
          POP: POP specifies data retrieval. It means that data is being deleted
          from the stack.
        </li>
        <li id="postfix">
          An expression in which operators follow the operands is known as
          postfix expression. The main benefit of this form is that there is no
          need to group sub-expressions in parentheses or to consider operator
          precedence. The expression "a + b" will be represented as "ab+" in
          postfix notation.
        </li>
        <li id="array">
          Arrays are defined as the collection of similar types of data items
          stored at contiguous memory locations. It is the simplest data
          structure in which each data element can be randomly accessed by using
          its index number.
        </li>
        <li id="one-d">
          It can be done by using an indexed loop such that the counter runs
          from 0 to the array size minus one. In this manner, you can reference
          all the elements in sequence by using the loop counter as the array
          subscript.
        </li>
        <li id="mul-d">
          The multidimensional array can be defined as the array of arrays in
          which, the data is stored in tabular form consists of rows and
          columns. 2D arrays are created to implement a relational database
          lookalike data structure. It provides ease of holding the bulk of data
          at once which can be passed to any number of functions wherever
          required.
        </li>
        <li id="mem">
          Row-Major Order: In row-major ordering, all the rows of the 2D array
          are stored into the memory contiguously. First, the 1st row of the
          array is stored into the memory completely, then the 2nd row of the
          array is stored into the memory completely and so on till the last
          row. Column-Major Order: In column-major ordering, all the columns of
          the 2D array are stored into the memory contiguously. first, the 1st
          column of the array is stored into the memory completely, then the 2nd
          row of the array is stored into the memory completely and so on till
          the last column of the array.
        </li>
        <li id="link-list">
          Linked List is the collection of randomly stored data objects called
          nodes. In Linked List, each node is linked to its adjacent node
          through a pointer. A node contains two fields, i.e. Data Field and
          Link Field.
        </li>
        <li id="cons">
          A linked list is considered both linear and non-linear data structure
          depending upon the situation. On the basis of data storage, it is
          considered as a non-linear data structure. On the basis of the access
          strategy, it is considered as a linear data-structure.
        </li>
        <li id="ad-array">
          The size of a linked list can be incremented at runtime which is
          impossible in the case of the array. The List is not required to be
          contiguously present in the main memory, if the contiguous space is
          not available, the nodes can be stored anywhere in the memory
          connected through the links. The List is dynamically stored in the
          main memory and grows as per the program demand while the array is
          statically stored in the main memory, size of which must be declared
          at compile time. The number of elements in the linked list are limited
          to the available memory space while the number of elements in the
          array is limited to the size of an array.
        </li>
        <li id="d-link">
          The doubly linked list is a complex type of linked list in which a
          node contains a pointer to the previous as well as the next node in
          the sequence. In a doubly linked list, a node consists of three parts:
          node data pointer to the next node in sequence (next pointer) pointer
          to the previous node (previous pointer).
        </li>
        <li id="queue">
          A queue can be defined as an ordered list which enables insert
          operations to be performed at one end called REAR and delete
          operations to be performed at another end called FRONT. FIFO(First In
          First Out)
        </li>
        <li id="queue-app">
          Queues are widely used as waiting lists for a single shared resource
          like a printer, disk, CPU. Queues are used in the asynchronous
          transfer of data (where data is not being transferred at the same rate
          between two processes) for eg. pipes, file IO, sockets. Queues are
          used as buffers in most of the applications like MP3 media player, CD
          player, etc. Queues are used to maintain the playlist in media players
          to add and remove the songs from the play-list. Queues are used in
          operating systems for handling interrupts.
        </li>
        <li id="dr-queue">
          Memory Wastage: The space of the array, which is used to store queue
          elements, can never be reused to store the elements of that queue
          because the elements can only be inserted at front end and the value
          of front might be so high so that, all the space before that, can
          never be filled. Array Size: There might be situations in which, we
          may need to extend the queue to insert more elements if we use an
          array to implement queue, It will almost be impossible to extend the
          array size, therefore deciding the correct array size is always a
          problem in array implementation of queue.
        </li>
        <li id="dequeue">
          Dequeue (also known as double-ended queue) can be defined as an
          ordered set of elements in which the insertion and deletion can be
          performed at both the ends, i.e. front and rear.
        </li>
        <li id="minimum">
          Two queues are needed. One queue is used to store the data elements,
          and another is used for storing priorities.
        </li>
        <li id="tree">
          The Tree is a recursive data structure containing the set of one or
          more data nodes where one node is designated as the root of the tree
          while the remaining nodes are called as the children of the root. The
          nodes other than the root node are partitioned into the nonempty sets
          where each one of them is to be called sub-tree.
        </li>
        <li id="tree-list">
          General Tree Forests Binary Tree Binary Search Tree Expression Tree
          Tournament Tree
        </li>
        <li id="bin">
          A binary Tree is a special type of generic tree in which, each node
          can have at most two children. Binary tree is generally partitioned
          into three disjoint subsets, i.e. the root of the node, left sub-tree
          and Right binary sub-tree.
        </li>
        <li id="nodes">2k+1-1 where k >= 1</li>
        <li id="suits">Queue data structure</li>
        <li id="prop">
          A B tree of order m contains all the properties of an M way tree. In
          addition, it contains the following properties. Every node in a B-Tree
          contains at most m children. Every node in a B-Tree except the root
          node and the leaf node contain at least m/2 children. The root nodes
          must have at least 2 nodes. All leaf nodes must be at the same level.
        </li>
        <li id="tree-ds">
          The manipulation of Arithmetic expression, Symbol Table construction,
          Syntax analysis Hierarchal data model
        </li>
        <li id="graph">
          A graph G can be defined as an ordered set G(V, E) where V(G)
          represents the set of vertices and E(G) represents the set of edges
          which are used to connect these vertices. A graph can be seen as a
          cyclic tree, where the vertices (Nodes) maintain any complex
          relationship among them instead of having parent-child relations.
          <br />
          Uses: Google Maps <br />
          Linkedin <br />
          Facebook <br />
        </li>
        <li id="cycle">
          Path: A Path is the sequence of adjacent vertices connected by the
          edges with no restrictions. Cycle: A Cycle can be defined as the
          closed path where the initial vertex is identical to the end vertex.
          Any vertex in the path can not be visited twice Circuit: A Circuit can
          be defined as the closed path where the intial vertex is identical to
          the end vertex. Any vertex may be repeated.
        </li>
        <li id="imple">
          In sequential representation, Adjacency matrix is used. In Linked
          representation, Adjacency list is used.
        </li>
        <li id="bfs">
          In BFS algorithm, Queue data structure is used. In DFS algorithm,
          Stack data structure is used.
        </li>
        <li id="graph-data">
          Graphs are used in circuit networks where points of connection are
          drawn as vertices and component wires become the edges of the graph.
          Graphs are used in transport networks where stations are drawn as
          vertices and routes become the edges of the graph. Graphs are used in
          maps that draw cities/states/regions as vertices and adjacency
          relations as edges. Graphs are used in program flow analysis where
          procedures or modules are treated as vertices and calls to these
          procedures are drawn as edges of the graph.
        </li>
        <li id="scene">
          Binary Search algorithm is used to search an already sorted list. The
          algorithm follows divide and conqer approach
        </li>
        <li id="advantage">
          There are relatively less number of comparisons in binary search than
          that in linear search. In average case, linear search takes O(n) time
          to search a list of n elements while Binary search takes O(log n) time
          to search a list of n elements.
        </li>
        <li id="selection">
          It is simple and easy to implement. It can be used for small data
          sets. It is 60 per cent more efficient than bubble sort.
        </li>
        <li id="multi-linked">Sparse matrix, Index generation.</li>
        <li id="null">
          Null is actually a value, whereas Void is a data type identifier. A
          null variable simply indicates an empty value, whereas void is used to
          identify pointers as having no initial size.
        </li>
        <li id="hash">
          Hash tables are a complex data structure capable of storing large
          amounts of information and retrieving specific elements efficiently.
          This data structure relies on the concept of key/value pairs, where
          the “key” is a searched string and the “value” is the data paired with
          that key. <br />
          Complexity: O(1)
        </li>
        <li id="implement">
          A queue can be implemented using two stacks. Let q be the queue
          andstack1 and stack2 be the 2 stacks for implementing q. We know that
          stack supports push, pop, peek operations and using these operations,
          we need to emulate the operations of queue - enqueue and dequeue.
          Hence, queue q can be implemented in two methods (Both the methods use
          auxillary space complexity of O(n)): <br />
          By making enqueue operation costly: <br />
          Here, the oldest element is always at the top of stack1 which ensures
          dequeue operation to occur in O(1) time complexity. To place element
          at top of stack1, stack2 is used. Pseudocode: <br />

          Enqueue: Here time complexity will be O(n) enqueue(q, data): While
          stack1 is not empty: Push everything from stack1 to stack2. Push data
          to stack1 Push everything back to stack1. <br />
          Dequeue: Here time complexity will be O(1) <br />

          deQueue(q): If stack1 is empty then error else Pop an item from stack1
          and return it <br />
          By making dequeue operation costly: <br />
          Here, for enqueue operation, the new element is pushed at the top of
          stack1. Here, the enqueue operation time complexity is O(1). In
          dequeue, if stack2 is empty, all elements from stack1 are moved to
          stack2 and top of stack2 is the result. Basically, reversing the list
          by pushing to a stack and returning the first enqueued element. This
          operation of pushing all elements to new stack takes O(n) complexity.
          Pseudocode: <br />
          Enqueue: Time complexity: O(1) enqueue(q, data): Push data to stack1
          <br />
          Dequeue: Time complexity: O(n) <br />
          dequeue(q): <br />
          If both stacks are empty then raise error. If stack2 is empty: While
          stack1 is not empty: push everything from stack1 to stack2. Pop the
          element from stack2 and return it.
        </li>
        <li id="hashmap">
          The key or value object that gets used in hashmap must implement
          equals() and hashcode() method. <br />
          The hash code is used when inserting the key object into the map and
          equals method is used when trying to retrieve a value from the map.
        </li>
        <li id="basic">
          The time complexity is O(1) assuming that the hash function used in
          hash map distributes elements uniformly among the buckets.
        </li>
        <li id="lru">
          LRU cache or Least Recently Used cache allows quick identification of
          an element that hasn’t been put to use for the longest time by
          organizing items in order of use. In order to achieve this, two data
          structures are used: <br />
          Queue <br />
          Hashmap
        </li>
        <li id="prio">
          A priority queue is an abstract data type that is like a normal queue
          but has priority assigned to elements. Elements with higher priority
          are processed before the elements with a lower priority. In order to
          implement this, a minimum of two queues are required - one for the
          data and the other to store the priority.
        </li>
        <li id="dup">
          No, duplicate keys cannot be inserted in HashMap. If you try to insert
          any entry with an existing key, then the old value would be overridden
          with the new value. Doing this will not change the size of HashMap.
          This is why the keySet() method returns all keys as a SET in Java
          since it doesn't allow duplicates.
        </li>
        <li id="t-traverse">
          Tree traversal is a process of visiting all the nodes of a tree. Since
          root (head) is the first node and all nodes are connected via edges
          (or links) we always start with that node. There are three ways which
          we use to traverse a tree − <br />
          Inorder <br />
          Preorder <br />
          Postorder
        </li>
        <li id="bst">
          A binary search tree (BST) is a variant of binary tree data structure
          that stores data in a very efficient manner such that the values of
          the nodes in the left sub-tree are less than the value of the root
          node, and the values of the nodes on the right of the root node are
          correspondingly higher than the root.
        </li>
        <li id="avl">
          AVL trees are height balancing BST. AVL tree checks the height of left
          and right sub-trees and assures that the difference is not more than
          1. This difference is called Balance Factor and is calculates as.
          BalanceFactor = height(left subtree) − height(right subtree)
        </li>
        <li id="bfs">
          Breadth first search is a graph traversal algorithm that starts
          traversing the graph from root node and explores all the neighbouring
          nodes. Then, it selects the nearest node and explore all the
          unexplored nodes. The algorithm follows the same process for each of
          the nearest node until it finds the goal.
        </li>
        <li id="dfs">
          Depth first search (DFS) algorithm starts with the initial node of the
          graph G, and then goes to deeper and deeper until we find the goal
          node or the node which has no children. The algorithm, then backtracks
          from the dead end towards the most recent node that is yet to be
          completely unexplored.
        </li>
        <li id="topo">
          Topological sorting is a linear ordering of vertices such that for
          every directed edge ij, vertex i comes before j in the ordering.
          Topological sorting is only possible for Directed Acyclic Graph (DAG).
          Applications: <br />
          jobs scheduling from the given dependencies among jobs. <br />
          ordering of formula cell evaluation in spreadsheets <br />
          ordering of compilation tasks to be performed in make files, data
          serialization <br />
          resolving symbol dependencies in linkers.
        </li>
        <li id="heap">
          Heap is a special tree-based non-linear data structure in which the
          tree is a complete binary tree. A binary tree is said to be complete
          if all levels are completely filled except possibly the last level and
          the last level has all elements towards as left as possible. Heaps are
          of two types: <br />

          Max-Heap: In a Max-Heap the data element present at the root node must
          be greatest among all the data elements present in the tree. This
          property should be recursively true for all sub-trees of that binary
          tree. <br />
          Min-Heap: In a Min-Heap the data element present at the root node must
          be the smallest (or minimum) among all the data elements present in
          the tree. This property should be recursively true for all sub-trees
          of that binary tree.
        </li>
        <li id="algo">
          An algorithm is a well-defined computational procedure that takes some
          values or the set of values, as an input and produces a set of values
          or some values, as an output.
        </li>
        <li id="need">
          The algorithm improves the efficiency of an existing technique. <br />
          To compare the performance of the algorithm with respect to other
          techniques. <br />
          The algorithm gives a strong description of requirements and goal of
          the problems to the designer. <br />
          The algorithm provides a reasonable understanding of the flow of the
          program. <br />
          The algorithm measures the performance of the methods in different
          cases (Best cases, worst cases, average cases). <br />
          The algorithm identifies the resources (input/output, memory) cycles
          required by the algorithm. <br />
          With the help of an algorithm, we can measure and analyze the
          complexity time and space of the problems. <br />
          The algorithm also reduces the cost of design.
        </li>
        <li id="comp">
          The complexity of the algorithm is a way to classify how efficient an
          algorithm is compared to alternative ones. Its focus is on how
          execution time increases with the data set to be processed.
        </li>
        <li id="rev">
          Step1: start <br />
          Step2: Take two variable i and j <br />
          Step3: do length (string)-1, to set J at last position <br />
          Step4: do string [0], to set i on the first character. <br />
          Step5: string [i] is interchanged with string[j] <br />
          Step6: Increment i by 1 <br />
          Step7: Increment j by 1 <br />
          Step8: if i>j then go to step3 <br />
          Step9: Stop
        </li>
        <li id="greedy">
          A greedy algorithm is a simple, intuitive algorithm that is used in
          optimization problems. The algorithm makes the optimal choice at each
          step as it attempts to find the overall optimal way to solve the
          entire problem.
        </li>
        <li id="app">
          Travelling Salesman Problem <br />
          Prim's Minimal Spanning Tree Algorithm <br />
          Kruskal's Minimal Spanning Tree Algorithm <br />
          Dijkstra's Minimal Spanning Tree Algorithm <br />
          Graph - Map Coloring <br />
          Graph - Vertex Cover <br />
          Knapsack Problem <br />
          Job Scheduling Problem
        </li>
        <li id="divide">
          In divide and conquer approach, the problem in hand, is divided into
          smaller sub-problems and then each problem is solved independently.
          When we keep on dividing the subproblems into even smaller
          sub-problems, we may eventually reach a stage where no more division
          is possible.
        </li>
        <li id="dynamic">
          Dynamic Programming (DP) is an algorithmic technique for solving an
          optimization problem by breaking it down into simpler subproblems and
          utilizing the fact that the optimal solution to the overall problem
          depends upon the optimal solution to its subproblems.
        </li>
        <li id="circle">
          Circular Linked List is a variation of Linked list in which the first
          element points to the last element and the last element points to the
          first element. Both Singly Linked List and Doubly Linked List can be
          made into a circular linked list. <br />
          Basic Operations: <br />
          Insert, Delete and Display
        </li>
        <li id="note">
          The way to write arithmetic expression is known as a notation. An
          arithmetic expression can be written in three different but equivalent
          notations: <br />
          Infix Notation, Prefix (Polish) Notation, Postfix (Reverse-Polish)
          Notation <br />
          Infix: We write expression in infix notation, e.g. a - b + c, where
          operators are used in-between operands. <br />
          Prefix: In this notation, operator is prefixed to operands, i.e.
          operator is written ahead of operands. For example, +ab. <br />
          Postfix: This notation style is known as Reversed Polish Notation. In
          this notation style, the operator is postfixed to the operands i.e.,
          the operator is written after the operands. For example, ab+.
        </li>
        <li id="line">
          Linear search is a very simple search algorithm. In this type of
          search, a sequential search is made over all items one by one. Every
          item is checked and if a match is found then that particular item is
          returned, otherwise the search continues till the end of the data
          collection.
        </li>
        <li id="searc">
          Linear Search. <br />
          Binary Search. <br />
          Jump Search. <br />
          Interpolation Search. <br />
          Exponential Search. <br />
        </li>
        <li id="dyna">
          A dynamic array is an array with a modification that is automatic
          resizing. This means that the array expands when we add more elements.
          This helps to provide flexibility as size is not fixed. So, there’s no
          need to know the size in advance.
        </li>
        <li id="charac">
          Array elements are stored in contiguous memory blocks in the primary
          memory. <br />
          Array name represents its base address. <br />
          The base address is the address of the first element of the array.
          <br />
          Array’s index starts with 0 and ends with size-1.
        </li>
        <li id="tip">
          Singly Linked list <br />
          Doubly Linked list <br />
          Circular Linked list <br />
          Doubly Circular Linked list
        </li>
        <li id="lif">
          LIFO: (Last-In-First-Out) Last inserted element is removed first in
          the LIFO principle. Example: Stack follows LIFO. <br />
          FIFO: (First-In-First-Out) First Element (first to be inserted) is
          taken out first. Example: Queue follows FIFO
        </li>
        <li id="prio">
          A priority queue is like a normal queue of elements but here each
          element has some priority. The elements in the priority queue occur in
          this order only. <br />
          Say, we have some values like 1, 2, 7, 8, 14, 31 inserted in a
          priority queue with an ordering based on least values to the greatest
          value. Therefore, the 1 number will have the highest priority while 31
          will have the lowest priority.
        </li>
        <li id="hp">
          A binary heap is a complete binary tree that satisfies the heap
          ordering property. A Binary Heap can either be Min Heap or Max Heap.
          It’s a complete tree, thus it is suitable for being stored in an
          array.
        </li>
        <li id="what">
          Stack <br />
          Queue <br />
          Linked List <br />
          Binary Tree
        </li>
        <li id="over">
          When a stack is completely full and we try to insert more elements
          onto the stack then this condition is called stack overflow condition.
          Here, top=maxsize-1, and no further elements can be inserted.
        </li>
        <li id="bal">
          A tree is perfectly height-balanced if the left and right subtrees of
          any node are of the same height. We can also say that a tree is
          height-balanced if the heights of the left and right subtrees of each
          node differ by a maximum of one unit.
        </li>
        <li id="rep">
          Adjacency matrix <br />
          Adjacency list <br />
          And adjacency set
        </li>
        <li id="bin">
          In this type of search technique, we divide the sorted array or list
          into two halves. This is done to save time in searching. Here, we
          consider arrays in sorted form only.
        </li>
        <li id="lin">
          Linear search is a technique in which we traverse a list in a
          sequential manner to find an element. When we find the element that is
          required, we return the index or position of that element.
        </li>
        <li id="tim">Linear Search-O(N) Binary Search- O(log 2 N)</li>
        <li id="trav">
          Tree traversal is a process that goes through the entire tree in a
          particular manner. Depending upon the order of traversal, we have
          different types: <br />
          Inorder Traversal (Left, Root, Right) <br />
          Preorder Traversal (Root, Left, Right) <br />
          Postorder Traversal (Left, Right, Root)
        </li>
        <li id="kruk">
          Kruskal algorithm treats a graph as a forest and every node as an
          individual tree. A tree connects to another only and only if it has
          the least cost among all available choices without violating Minimum
          Spanning Tree (MST) properties.
        </li>
        <li id="prim">
          Prim's Algorithm is used to find the minimum spanning tree from a
          graph. Prim's algorithm finds the subset of edges that includes every
          vertex of the graph such that the sum of the weights of the edges can
          be minimized. <br />
          Prim's algorithm starts with the single node and explore all the
          adjacent nodes with all the connecting edges at every step. The edges
          with the minimal weights causing no cycles in the graph got selected.
        </li>
        <li id="mst">
          It is a spanning tree that has the minimum weight among all the
          spanning trees of the same graph.
        </li>
        <li id="hanoi">
          The Tower of Hanoi is a problem that comprises three rods and multiple
          disks. <br />
          At the start, all the disks are placed on one rod, one over the other
          in increasing order. <br />
          The aim of this problem is to move the stack of disks from the
          starting rod to another rod, following these rules as below: <br />
          A disk cannot be placed on top of a smaller disk <br />
          No disk can be placed on top of the smaller disk.
        </li>
        <li id="rec">
          Recursion in general is a function calling itself. Extending the same
          logic for Algorithms, we can say that an algorithm that calls itself
          is a recursive algorithm. One good example of their use would be
          searching through a file system. Usually, they are used when the
          iterative approach is not useful for complex problems.
        </li>
        <li id="why">
          A stack is a recursive data structure because: <br />
          A stack can either be empty or <br />
          It will have a top pointer and the rest part apart from the top is
          also a stack by itself, thus it’s recursive.
        </li>
        <li id="comp">The time complexity of MergeSort is O(n*log n)</li>
        <li id="shell">
          Shell sort is a sorting algorithm based on the insertion sort
          algorithm. <br />
          This algorithm is highly efficient in sorting. This algorithm tries to
          avoid large shifts as in the case of insertion sort if the smaller
          value is to the far right and has to be moved to the far left.
        </li>
        <li id="is">Worst-case time complexity is O(n^2)</li>
        <li id="red">
          A red-black tree is a binary tree that has nodes represented by two
          colors: red and black. The tree follows specific properties. <br />
          These include: <br />
          The root node of the tree is always black. <br />
          Every path from the root to any of the leaf nodes should have the same
          number of black nodes. <br />
          No two red nodes can be adjacent to each other.
        </li>
        <li id="occ">
          It occurs when the picked pivot is an extreme (smallest or largest)
          element. Usually, when the input array is sorted or reverse sorted, it
          also leads to the worst case.
        </li>
        <li id="are">
          For BFS - Queue Data Structure <br />
          For DFS - Stack Data Structure
        </li>
      </ol>
    </div>
  </body>
</html>
